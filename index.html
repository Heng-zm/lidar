<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Real-Time Video to 3D Cloud</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: monospace; }
        #ui {
            position: absolute; top: 10px; left: 10px; color: #0f0;
            background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #0f0;
            pointer-events: none; z-index: 10;
        }
        #webcam { display: none; } /* Hide raw video, we only show 3D */
    </style>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="ui">
        <strong>REAL-TIME 3D RECONSTRUCTION</strong><br>
        1. Converting Video Pixels to XYZ Points<br>
        2. Mapping Brightness to Depth (Z-Axis)<br>
        <br>
        [Left Click]: Rotate Cloud<br>
        [Right Click]: Pan<br>
        [Scroll]: Zoom
    </div>

    <!-- Hidden Video Element -->
    <video id="webcam" autoplay playsinline muted></video>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURATION ---
        const WIDTH = 160;  // Resolution X (Lower is faster)
        const HEIGHT = 120; // Resolution Y
        const SEPARATION = 1.5; // Distance between points

        // --- 1. SETUP WEBCAM ---
        const video = document.getElementById('webcam');
        
        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 } 
                });
                video.srcObject = stream;
            } catch (err) {
                alert("Camera Access Denied. Please allow camera.");
            }
        }
        initCamera();

        // --- 2. SETUP 3D SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 500;

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 3. CREATE PARTICLES (THE "CLOUD") ---
        // We create a fixed grid of points. We will move them every frame.
        const numParticles = WIDTH * HEIGHT;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(numParticles * 3);
        const colors = new Float32Array(numParticles * 3);

        // Initialize grid positions
        let i = 0;
        for (let ix = 0; ix < WIDTH; ix++) {
            for (let iy = 0; iy < HEIGHT; iy++) {
                // Center the grid
                positions[i] = (ix * SEPARATION) - ((WIDTH * SEPARATION) / 2); // X
                positions[i + 1] = (iy * SEPARATION) - ((HEIGHT * SEPARATION) / 2); // Y
                positions[i + 2] = 0; // Z (Depth) - We will update this live!
                i += 3;
            }
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 2.0,
            vertexColors: true,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 4. PROCESSING LOOP ---
        // Create a temporary canvas to read video pixels
        const canvas = document.createElement('canvas');
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        function animate() {
            requestAnimationFrame(animate);

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                // A. Draw video to small canvas
                ctx.drawImage(video, 0, 0, WIDTH, HEIGHT);
                
                // B. Get Raw Pixel Data (R, G, B, A)
                const imgData = ctx.getImageData(0, 0, WIDTH, HEIGHT).data;

                // C. Update 3D Points
                const positions = particles.geometry.attributes.position.array;
                const colors = particles.geometry.attributes.color.array;

                let j = 0; // Index for positions/colors
                let k = 0; // Index for pixels (r,g,b,a)

                // Loop through every "pixel" in our 3D grid
                for (let ix = 0; ix < WIDTH; ix++) {
                    for (let iy = 0; iy < HEIGHT; iy++) {
                        
                        const r = imgData[k];
                        const g = imgData[k + 1];
                        const b = imgData[k + 2];

                        // Calculate Brightness
                        const brightness = (r + g + b) / 3;

                        // --- THE MAGIC: Z-DISPLACEMENT ---
                        // We push bright pixels forward and dark pixels back
                        // This creates a 3D topology map of the video
                        const z = brightness * 0.8; 

                        // Update Z position
                        // Note: We flip Y (HEIGHT - iy) because Canvas 0,0 is top-left, 3D is center
                        positions[j + 2] = z; 

                        // Update Color (True Color)
                        colors[j] = r / 255;
                        colors[j + 1] = g / 255;
                        colors[j + 2] = b / 255;

                        j += 3;
                        k += 4;
                    }
                }

                // Tell Three.js to redraw geometry
                particles.geometry.attributes.position.needsUpdate = true;
                particles.geometry.attributes.color.needsUpdate = true;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
